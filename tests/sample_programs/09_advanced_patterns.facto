# Test 9: Advanced patterns - counters, filters, accumulators
# Tests: complex memory patterns, filtering, accumulation

# Multi-counter system
Memory up_counter: "signal-0";
Memory down_counter: "signal-0";
Memory event_count: "signal-0";


Signal increment = (("signal-I", 0) > 0) | "signal-0";
Signal decrement = (("signal-D", 1) > 0) | "signal-0";
Signal reset = (("signal-R", 2) > 0) | "signal-0";

# Counter logic with bounds checking
Signal up_val = up_counter.read();
Signal down_val = down_counter.read();

Signal new_up = 
    reset * 0 + 
    (1 - reset) * (up_val + increment * (up_val < 999));

Signal new_down = 
    reset * 100 + 
    (1 - reset) * (down_val - decrement * (down_val > 0));

up_counter.write(new_up);
down_counter.write(new_down);

# Event detection and counting
Signal up_overflow = (up_val >= 999) && increment;
Signal down_underflow = (down_val <= 0) && decrement;
Signal any_event = up_overflow || down_underflow;

Signal events = event_count.read();
event_count.write(events + any_event);

# Filtered accumulator - only accumulate positive values
Memory filtered_sum: "signal-0";

Signal input_val = 130;
Signal should_accumulate = input_val > 0;
Signal current_sum = filtered_sum.read();
filtered_sum.write(current_sum + (input_val * should_accumulate));

# Output status projections without bundles
Signal status_up = up_val | "signal-red";
Signal status_down = down_val | "signal-green";
Signal status_events = events | "signal-blue";
Signal status_sum = current_sum | "signal-yellow";
