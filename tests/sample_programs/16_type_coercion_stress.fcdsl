# Test 16: Type coercion and mixed operations stress test
# Tests: complex type mixing, coercion edge cases, signal type interactions

# Various input types
Signal implicit1 = input(0);                    # __v1
Signal implicit2 = input(1);                    # __v2  
Signal iron = input("iron-plate", 2);
Signal copper = input("copper-plate", 3);
Signal signal_a = input("signal-A", 4);

# Integer literals
Signal int_val = 42;
Signal zero = 0;
Signal negative = -15;

# Basic type mixing (should generate warnings)
Signal mixed1 = implicit1 + iron;               # implicit + explicit -> implicit type
Signal mixed2 = iron + copper;                  # explicit + explicit -> iron-plate type
Signal mixed3 = implicit1 + implicit2;          # implicit + implicit -> first type

# Integer coercion
Signal coerced1 = iron + int_val;               # int coerced to iron-plate
Signal coerced2 = int_val * implicit1;          # int coerced to implicit1 type
Signal coerced3 = copper - negative;            # int coerced to copper-plate

# Chain of mixed operations (multiple warnings expected)
Signal chain1 = implicit1 + iron + copper;     # __v1 + iron -> __v1, then __v1 + copper -> __v1
Signal chain2 = iron + implicit1 + copper;     # iron + __v1 -> iron, then iron + copper -> iron

# Bundle type mixing
Bundle mixed_bundle = bundle(implicit1, iron, copper);
Bundle bundle_arithmetic = mixed_bundle + implicit2;    # bundle + signal

# Projection type changes  
Signal proj1 = mixed1 | "steel-plate";         # change type via projection
Signal proj2 = mixed_bundle | "coal";          # project bundle to different type

# Complex nested type mixing
Signal complex_mixed = (implicit1 + iron) * (copper - implicit2) + signal_a;

# Type mixing in comparisons
Signal comparison_mixed1 = implicit1 > iron;           # comparing different types
Signal comparison_mixed2 = iron == copper;             # comparing different explicit types
Signal comparison_mixed3 = implicit1 < int_val;       # implicit vs integer

# Logical operations with mixed types
Signal logical_mixed = (implicit1 > 0) && (iron > copper);

# Bundle projections with type mixing
Bundle bundle_proj_mixed = bundle(implicit1 + iron, copper * implicit2);
Signal final_proj = bundle_proj_mixed | "wood";        # project to unrelated type

# Memory operations with type mixing
mem mixed_memory = memory(implicit1 + iron);
write(mixed_memory, copper + implicit2);
Signal memory_read = read(mixed_memory);

# Function with type mixing
func mixed_type_function(param1, param2) {
    Signal local_mixed = param1 + iron;
    Signal result = local_mixed * param2 + copper;
    return result;
}

Signal func_result = mixed_type_function(implicit1, implicit2);

# Extreme type mixing chain
Signal extreme_chain = ((implicit1 + iron) * (copper - signal_a)) / (implicit2 + int_val) | "uranium-ore";
