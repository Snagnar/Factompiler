# Test 16: Type coercion and mixed operations stress test
# Tests: complex type mixing, coercion edge cases, signal type interactions

# Various input types
Signal implicit1 = 100;                    # __v1
Signal implicit2 = 110;                    # __v2  
Signal iron = ("iron-plate", 2);
Signal copper = ("copper-plate", 3);
Signal signal_a = ("signal-A", 4);

# Integer literals
Signal int_val = 42;
Signal zero = 0;
Signal negative = -15;

# Basic type mixing (should generate warnings)
Signal mixed1 = implicit1 + iron;               # implicit + explicit -> implicit type
Signal mixed2 = iron + copper;                  # explicit + explicit -> iron-plate type
Signal mixed3 = implicit1 + implicit2;          # implicit + implicit -> first type

# Integer coercion
Signal coerced1 = iron + int_val;               # int coerced to iron-plate
Signal coerced2 = int_val * implicit1;          # int coerced to implicit1 type
Signal coerced3 = copper - negative;            # int coerced to copper-plate

# Chain of mixed operations (multiple warnings expected)
Signal chain1 = implicit1 + iron + copper;     # __v1 + iron -> __v1, then __v1 + copper -> __v1
Signal chain2 = iron + implicit1 + copper;     # iron + __v1 -> iron, then iron + copper -> iron

# Aggregated type mixing without bundles
Signal mixed_aggregate = (implicit1 | "signal-A") + iron + copper;
Signal bundle_arithmetic = (mixed_aggregate + implicit2) | "signal-A";    # aggregate + signal

# Projection type changes  
Signal proj1 = mixed1 | "steel-plate";         # change type via projection
Signal proj2 = mixed_aggregate | "coal";          # project aggregated signal to different type

# Complex nested type mixing
Signal complex_mixed = (implicit1 + iron) * (copper - implicit2) + signal_a;

# Type mixing in comparisons
Signal comparison_mixed1 = implicit1 > iron;           # comparing different types
Signal comparison_mixed2 = iron == copper;             # comparing different explicit types
Signal comparison_mixed3 = implicit1 < int_val;       # implicit vs integer

# Logical operations with mixed types
Signal logical_mixed = (implicit1 > 0) && (iron > copper);

# Simulated bundle projection with aggregated signals
Signal bundle_proj_mixed = ( (implicit1 + iron) | "iron-plate" ) + ((copper * implicit2) | "copper-plate");
Signal final_proj = bundle_proj_mixed | "wood";        # project to unrelated type

# Memory operations with type mixing
Memory mixed_memory: "signal-0";

write((copper + implicit2) | "signal-0", mixed_memory, when=1);
Signal memory_read = read(mixed_memory);

# Function with type mixing
func mixed_type_function(param1, param2) {
    Signal local_mixed = param1 + iron;
    Signal result = local_mixed * param2 + copper;
    return result;
}

Signal func_result = mixed_type_function(implicit1, implicit2);

# Extreme type mixing chain
Signal extreme_chain = ((implicit1 + iron) * (copper - signal_a)) / (implicit2 + int_val) | "uranium-ore";
