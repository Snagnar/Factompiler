# Test 6: Functions and modularity
# Tests: func declaration, function calls, parameter passing, scoping, .type access

func double_signal(Signal x) {
    return x * 2;
}

func conditional_add(Signal a, Signal b, Signal condition) {
    Signal result = a + (b * condition);
    return result;
}

func choose(Signal a, Signal b, Signal condition) {
    return a * condition + b * !condition;
}

func memory_toggle() {
    Memory toggle_state: "signal-A";

    Signal current = toggle_state.read();
    Signal new_state = 1 - current;  # toggle between 0 and 1
    toggle_state.write(new_state);
    return new_state * 10;
}

# Function using .type to match the type of the input signal
func add_with_same_type(Signal input, int value) {
    Signal typed_value = value | input.type;
    return input + typed_value;
}


# Use functions
Signal input_val = 42;
Signal doubled = double_signal(input_val);

Signal condition = 50 > 0;
Signal computed = conditional_add(input_val, 5, condition);

Signal toggle_output = memory_toggle();

# Test .type inside function - should preserve iron-plate type
Signal iron = ("iron-plate", 100);
Signal iron_plus_fifty = add_with_same_type(iron, 50);

# Nested function calls
Signal complex_result = conditional_add(
    double_signal(input_val),
    120,
    toggle_output
);
