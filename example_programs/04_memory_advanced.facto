# Advanced Memory Module Test
# Demonstrates full memory capabilities including:
# - Storing arbitrary signal types (items, fluids, virtuals)
# - Conditional writes based on signal values
# - Reading and manipulating stored values
# - Memory state machines

# =============================================================================
# BASIC MEMORY STORAGE - Different Signal Types
# =============================================================================

# Store an item signal
Memory iron_storage: "iron-plate";
Memory copper_storage: "copper-plate";

# Store a fluid signal
Memory water_level: "water";

# Store a virtual signal for state
Memory system_state: "signal-S";

# Store a counter
Memory tick_counter: "signal-0";

# =============================================================================
# CONDITIONAL WRITES - Write only when conditions are met
# =============================================================================

# Scenario 1: Write only if current value is zero (initialization check)
# CORRECT PATTERN: Read current value, write new value if condition met, otherwise write current value back
Signal current_iron = iron_storage.read();
Signal iron_input = 50 | "iron-plate";
Signal should_write_iron = (current_iron == 0);  # 1 if true, 0 if false

# Scenario 2: Write only if input exceeds threshold
Signal copper_input = 75 | "copper-plate";
Signal should_store_copper = copper_input > 100;  # Boolean: 1 if true, 0 if false
Signal copper_current = copper_storage.read();

# Scenario 3: Conditional increment - add to counter only if condition met
Signal current_count = tick_counter.read();
Signal enable_counting = 1;  # This could be from any condition
Signal new_count = current_count + (enable_counting | "signal-0");
tick_counter.write(new_count, when=enable_counting);  # Only writes when counting is enabled

# =============================================================================
# COMPLEX CONDITIONAL WRITES - Multiple Conditions
# =============================================================================

# Write to water storage only if:
# 1. Current level is low (< 500), AND
# 2. Pump is active (simulated), AND
# 3. Input is available
Signal current_water = water_level.read();
Signal water_is_low = current_water < 500;
Signal pump_active = 1;  # Simulated
Signal water_input = 200 | "water";
Signal should_refill = water_is_low && pump_active;
Signal water_refill_value = current_water + water_input;
water_level.write(water_refill_value, when=should_refill);

# =============================================================================
# MEMORY-BASED STATE MACHINE
# =============================================================================

# State machine: 0 = idle, 1 = processing, 2 = complete, 3 = error
Signal current_state = system_state.read();

# Transitions based on conditions
Signal has_input = iron_input > 0;
Signal processing_done = current_count > 10;
Signal has_error = 0;  # Simulated error condition

# State transition logic
Signal idle_to_processing = (current_state == 0) && has_input;
Signal processing_to_complete = (current_state == 1) && processing_done;
Signal any_to_error = has_error;
Signal complete_to_idle = (current_state == 2);

Signal next_state = 
    ((idle_to_processing * 1) +           # Go to state 1
    (processing_to_complete * 2) +        # Go to state 2
    (complete_to_idle * 0) +              # Go to state 0
    (any_to_error * 3) +                  # Go to state 3
    (!(idle_to_processing || processing_to_complete || complete_to_idle || any_to_error)) * current_state) | "signal-S";  # Stay in current state

system_state.write(next_state);

# =============================================================================
# STORING MULTIPLE VALUES - Using Different Memory Cells
# =============================================================================

Memory max_iron_seen: "iron-plate";
Memory min_copper_seen: "copper-plate";

Signal current_max = max_iron_seen.read();
Signal should_update_max = iron_input > current_max;
max_iron_seen.write(iron_input, when=should_update_max);

Signal current_min = min_copper_seen.read();
Signal should_update_min = copper_input < current_min;
min_copper_seen.write(copper_input, when=should_update_min);

# =============================================================================
# CLEARING/RESETTING MEMORY
# =============================================================================

Signal reset_signal = 0;  # Set to 1 to trigger reset

# =============================================================================
# READING AND COMBINING MEMORY VALUES
# =============================================================================

# Read all storage values
Signal total_iron = iron_storage.read();
Signal total_copper = copper_storage.read();
Signal total_water = water_level.read();

# Combine for summary signal
Signal total_resources = (total_iron | "signal-R") + (total_copper | "signal-R") + (total_water / 10 | "signal-R");

# =============================================================================
# CONDITIONAL SWAP - Exchange values between memories
# =============================================================================

Signal should_swap = 0;  # Condition to swap iron and copper storage
Signal iron_after_swap = (should_swap * (copper_storage.read() | "iron-plate") + (!should_swap) * iron_storage.read());
Signal copper_after_swap = (should_swap * (iron_storage.read() | "copper-plate") + (!should_swap) * copper_storage.read());

# =============================================================================
# UNIFIED WRITE LOGIC - Combine all conditions into single write per memory
# =============================================================================

# Priority: reset > swap > conditional initialization
# For iron_storage: combines reset (line 113), swap (line 136), and init (line 34)
Signal iron_final_value = 
    (reset_signal * (0 | "iron-plate")) +                           # Reset takes priority
    ((!reset_signal && should_swap) * iron_after_swap) +            # Swap if no reset
    ((!reset_signal && !should_swap && should_write_iron) * iron_input) +  # Init if no reset/swap
    ((!reset_signal && !should_swap && !should_write_iron) * current_iron);  # Hold otherwise

iron_storage.write(iron_final_value);

# For copper_storage: combines reset (line 114), swap (line 137), and conditional (line 40)
Signal copper_final_value = 
    (reset_signal * (0 | "copper-plate")) +                         # Reset takes priority
    ((!reset_signal && should_swap) * copper_after_swap) +          # Swap if no reset
    ((!reset_signal && !should_swap && should_store_copper) * copper_input) +  # Store if no reset/swap
    ((!reset_signal && !should_swap && !should_store_copper) * copper_current);  # Hold otherwise

copper_storage.write(copper_final_value);

# =============================================================================
# OUTPUT SIGNALS - Based on Memory State
# =============================================================================

Signal storage_full = (total_iron > 1000) || (total_copper > 1000);
Signal storage_empty = (total_iron == 0) && (total_copper == 0);
Signal system_ready = (current_state == 0) && !storage_empty;
Signal system_processing = (current_state == 1);
Signal system_done = (current_state == 2);
