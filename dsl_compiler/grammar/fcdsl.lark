// fcdsl.lark
// Factorio Circuit DSL grammar (Lark format)
// Version 2.0 - Extended operator support

%import common.ESCAPED_STRING   -> STRING
%import common.WS_INLINE
%ignore WS_INLINE
%ignore /#[^\n]*/               // line comments start with #

// Number literals supporting multiple bases
NUMBER: HEX_NUMBER | OCT_NUMBER | BIN_NUMBER | DEC_NUMBER

HEX_NUMBER: /0[xX][0-9a-fA-F]+/
OCT_NUMBER: /0[oO][0-7]+/
BIN_NUMBER: /0[bB][01]+/
DEC_NUMBER: /[+-]?[0-9]+/

// Keywords for special forms (must come before NAME to take precedence)
READ_KW: "read"
WRITE_KW: "write"
WHEN_KW: "when"

// Type keywords
INT_KW: "int"
SIGNAL_KW: "Signal"
SIGNALTYPE_KW: "SignalType" 
ENTITY_KW: "Entity"
MEMORY_KW: "Memory"

// Operator Tokens
// Note: Lark automatically handles longest-match, but we define multi-char operators first for clarity
POWER_OP: "**"
SHIFT_OP.2: "<<" | ">>"
LOGIC_AND: "&&" | "and"
LOGIC_OR: "||" | "or"
COMP_OP: "==" | "!=" | "<=" | ">=" | "<" | ">"
BITWISE_AND: "AND"
BITWISE_XOR: "XOR"
BITWISE_OR: "OR"
MUL_OP: "*" | "/" | "%"
ADD_OP: "+" | "-"
OUTPUT_SPEC: ":"
PROJ_OP: "|"
UNARY_OP: "+" | "-" | "!"

NAME: /[A-Za-z_][A-Za-z0-9_]*/

// ---------------------------------
// Entry point
// ---------------------------------
start: statement*

// ---------------------------------
// Statements (terminated by semicolon), and decls
// ---------------------------------
statement: decl_stmt ";"                    -> decl_stmt
         | assign_stmt ";"                  -> assign_stmt
         | expr_stmt ";"                    -> statement_expr_stmt
         | return_stmt ";"                  -> return_stmt
         | import_stmt ";"                  -> import_stmt
         | func_decl                        -> func_decl   // function bodies contain their own semicolons
         | mem_decl ";"                     -> mem_decl

decl_stmt: type_name NAME "=" expr

mem_decl: MEMORY_KW NAME [":" STRING]

type_name: INT_KW | SIGNAL_KW | SIGNALTYPE_KW | ENTITY_KW

assign_stmt: lvalue "=" expr

lvalue: NAME ("." NAME)?                    // variable or property assign (e.g. lamp.enable)

expr_stmt: expr

return_stmt: "return" expr

import_stmt: "import" STRING ["as" NAME]

// ---------------------------------
// Functions
// ---------------------------------
func_decl: "func" NAME "(" [param_list] ")" "{" statement* "}"

param_list: NAME ("," NAME)*

// ---------------------------------
// Expressions with precedence
// Precedence from LOWEST (loosest) to HIGHEST (tightest):
//  logic_or -> logic_and -> output_spec -> comparison -> projection -> 
//  bitwise_or -> bitwise_xor -> bitwise_and -> shift -> add -> mul -> power -> unary -> primary
// ---------------------------------
expr: logic_or

logic_or: logic_and ( LOGIC_OR logic_and )*

logic_and: output_spec ( LOGIC_AND output_spec )*

// Output specifier for decider copy-count-from-input
output_spec: comparison [ OUTPUT_SPEC output_value ]

output_value: primary

comparison: projection ( COMP_OP projection )*

projection: bitwise_or ( PROJ_OP type_literal )*

bitwise_or: bitwise_xor ( BITWISE_OR bitwise_xor )*

bitwise_xor: bitwise_and ( BITWISE_XOR bitwise_and )*

bitwise_and: shift ( BITWISE_AND shift )*

shift: add ( SHIFT_OP add )*

add: mul ( ADD_OP mul )*

mul: power ( MUL_OP power )*

// Power is RIGHT-ASSOCIATIVE: 2**3**4 = 2**(3**4)
power: unary ( POWER_OP power )?

unary: UNARY_OP unary
     | primary

// primary expressions (constructors, calls, memory ops, property access)
primary: literal
     | signal_literal                       // New signal literal syntax
     | READ_KW "(" NAME ")"
     | WRITE_KW "(" expr "," NAME ["," WHEN_KW "=" write_when] ")"
     | dict_literal
       | call_expr                            // General function calls after specific forms
       | method_call
       | lvalue                               // Simple identifiers last
       | "(" expr ")"

write_when: expr

call_expr: NAME "(" [arglist] ")"
method_call: NAME "." NAME "(" [arglist] ")"

arglist: expr ("," expr)*

dict_literal: "{" [dict_item ("," dict_item)*] "}"
dict_item: (STRING | NAME) ":" expr

// Signal literal syntax: ("type", value) or just value
signal_literal: "(" type_literal "," expr ")"    -> signal_with_type
              | NUMBER                          -> signal_constant

type_literal: STRING
            | NAME

literal: STRING    -> string

// ---------------------------------
// Tokens & whitespace
// ---------------------------------
%ignore /[ \t\f\r\n]+/
%ignore /\/\/[^\r\n]*/  // Line comments
