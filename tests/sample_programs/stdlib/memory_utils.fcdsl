# Memory utilities library
# Provides common memory-based operations and patterns

func delay_signal(signal, delay_ticks) {
    # Simple delay using memory - stores signal for delay_ticks
    Memory delayed_value;
    Memory tick_counter;

    write(0, delayed_value, when=once);
    write(0, tick_counter, when=once);
    
    Signal ticks = read(tick_counter);
    Signal should_update = (ticks % delay_ticks) == 0;
    
    Signal current_delayed = read(delayed_value);
    Signal new_delayed = should_update * signal + (1 - should_update) * current_delayed;
    
    write(new_delayed, delayed_value, when=1);
    write(ticks + 1, tick_counter, when=1);
    
    return current_delayed;
}

func accumulate_clamped(signal, min_val, max_val) {
    # Accumulate signal with min/max bounds
    Memory accumulator;

    write(0, accumulator, when=once);
    
    Signal current = read(accumulator);
    Signal new_val = current + signal;
    
    # Clamp between min and max
    Signal clamped = (new_val < min_val) * min_val + 
                  (new_val > max_val) * max_val +
                  ((new_val >= min_val) && (new_val <= max_val)) * new_val;
    
    write(clamped, accumulator, when=1);
    return clamped;
}

func rate_limiter(signal, max_change_per_tick) {
    # Limit rate of change in signal
    Memory last_value;

    write(0, last_value, when=once);
    
    Signal last = read(last_value);
    Signal change = signal - last;
    Signal abs_change = (change >= 0) * change + (change < 0) * (-change);
    
    Signal limited_change = (abs_change > max_change_per_tick) * 
                        ((change >= 0) * max_change_per_tick + (change < 0) * (-max_change_per_tick)) +
                        (abs_change <= max_change_per_tick) * change;
    
    Signal new_value = last + limited_change;
    write(new_value, last_value, when=1);
    
    return new_value;
}
