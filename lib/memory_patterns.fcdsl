# =============================================================================
# Memory Patterns Standard Library
# =============================================================================
# Common memory patterns using the method-based syntax.
# Import with: import "lib/memory_patterns.fcdsl";
#
# Design principles:
# - Use conditional writes (when=) to avoid combinators when possible
# - Prefer simple arithmetic over complex conditional logic
# - Minimize intermediate signals to reduce combinator count
# =============================================================================

# -----------------------------------------------------------------------------
# Rising Edge Detector
# -----------------------------------------------------------------------------
# Outputs 1 for one tick when input transitions from 0 to non-zero.
# Uses: 1 memory (2 deciders for latch) + 1 decider for comparison
#
func edge_rising(Signal input) {
    Memory prev: "signal-P";
    Signal was_zero = prev.read() == 0;
    Signal is_nonzero = input > 0;
    prev.write(is_nonzero);
    return was_zero * is_nonzero;
}


# -----------------------------------------------------------------------------
# Falling Edge Detector
# -----------------------------------------------------------------------------
# Outputs 1 for one tick when input transitions from non-zero to 0.
# Uses: 1 memory (2 deciders for latch) + 1 decider for comparison
#
func edge_falling(Signal input) {
    Memory prev: "signal-P";
    Signal was_nonzero = prev.read() > 0;
    Signal is_zero = input == 0;
    prev.write(input > 0);
    return was_nonzero * is_zero;
}


# -----------------------------------------------------------------------------
# Modulo Counter (Clock)
# -----------------------------------------------------------------------------
# Counter that wraps at specified value. Optimized to arithmetic feedback.
#
func clock(int period) {
    Memory tick: "signal-T";
    tick.write((tick.read() + 1) % period);
    return tick.read();
}


# -----------------------------------------------------------------------------
# Pulse Stretcher
# -----------------------------------------------------------------------------
# Extends a 1-tick pulse to last for 'duration' ticks.
# Output is 1 while countdown > 0 or during trigger.
#
func pulse_stretch(Signal input, int duration) {
    Memory countdown: "signal-C";
    
    Signal triggered = input > 0;
    Signal current = countdown.read();
    Signal counting = (triggered == 0) && (current > 0);
    
    # MUX: if triggered → duration, elif counting → current-1, else → 0
    Signal next = triggered * duration 
                + counting * (current - 1);
    
    countdown.write(next);  # Single unconditional write!
    
    # Output: high while counting OR during trigger
    return (current > 0) || triggered;
}


# -----------------------------------------------------------------------------
# Debounce
# -----------------------------------------------------------------------------
# Requires input to be stable for 'ticks' before output changes.
# Filters out rapid toggles and glitches.
#
func debounce(Signal input, int ticks) {
    Memory output: "signal-O";
    Memory counter: "signal-C";
    
    Signal matches_output = input == output.read();
    Signal counter_val = counter.read();
    
    # When input matches output: count up
    # When input differs: reset counter
    Signal next_counter = matches_output * (counter_val + 1);
    counter.write(next_counter);
    
    # Update output when counter reaches threshold
    Signal reached = counter_val >= ticks;
    output.write(input, when=reached);
    
    return output.read();
}


# -----------------------------------------------------------------------------
# Rate Limiter
# -----------------------------------------------------------------------------
# Tracks input value but limits change to max_change per tick.
# Useful for smoothing out sudden value changes.
#
func rate_limit(Signal input, int max_change) {
    Memory current: "signal-R";
    
    Signal delta = input - current.read();
    
    # Clamp delta to [-max_change, max_change]
    # Use min/max pattern: result = (val > limit) * limit + (val <= limit) * val
    Signal abs_delta = (delta >= 0) * delta + (delta < 0) * (0 - delta);
    Signal sign = (delta >= 0) * 1 + (delta < 0) * (0 - 1);
    Signal clamped_abs = (abs_delta > max_change) * max_change 
                       + (abs_delta <= max_change) * abs_delta;
    Signal clamped_delta = sign * clamped_abs;
    
    current.write(current.read() + clamped_delta);
    return current.read();
}


# -----------------------------------------------------------------------------
# Exponential Moving Average
# -----------------------------------------------------------------------------
# Smooths signal using EMA formula: new = old + (input - old) * alpha
# Alpha is expressed as a fraction: alpha_num / alpha_denom
# Higher alpha = faster response, lower = smoother
#
# Example: ema(sensor_value, 1, 4) for 25% weight on new values
#
func ema(Signal input, int alpha_num, int alpha_denom) {
    Memory avg: "signal-E";
    
    Signal delta = input - avg.read();
    Signal adjustment = (delta * alpha_num) / alpha_denom;
    
    avg.write(avg.read() + adjustment);
    return avg.read();
}

# -----------------------------------------------------------------------------
# Delay Line (1-tick delay)
# -----------------------------------------------------------------------------
# Delays a signal by exactly 1 tick.
# Useful for synchronization and creating pipeline stages.
#
func delay(Signal input) {
    Memory prev: "signal-D";
    Signal output = prev.read();
    prev.write(input);
    return output;
}
