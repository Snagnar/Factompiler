# Test 8: The 100-tick sampler (from spec example)
# Tests: modulo operations, periodic sampling, complex logic chains

Memory tick: "signal-0";


Signal ONE = 1;

# Increment tick every game tick (unconditional write)
tick.write(tick.read() + ONE);

Signal tick_mod = tick.read() % 100;
Signal sample_now = tick_mod == 0;

Signal v = 100;           # implicit signal type __v1
Signal rem = v % 2;
Signal is_even = rem == 0;

Signal do_output = sample_now : is_even;    # 0/1 gate

Signal scaled = v * 10;
Signal out_value = do_output : scaled;

# Additional complexity: multiple sampling rates
Signal fast_sample = tick.read() % 10 == 0;
Signal slow_sample = tick.read() % 1000 == 0;

Signal fast_output = fast_sample : v;
Signal slow_output = slow_sample : (v / 5);

# Project outputs onto distinct channels without bundles
Signal out_red = out_value | "signal-red";
Signal out_fast_belt = fast_output | "fast-transport-belt";
Signal out_blue = slow_output | "signal-blue";

# Aggregate onto a single channel for export if needed
Signal combined_output = (out_red + out_fast_belt + out_blue) | "signal-each";
