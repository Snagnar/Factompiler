// facto.lark
// Facto language grammar (Lark format)
// Version 2.0 - Extended operator support

%import common.ESCAPED_STRING   -> STRING
%import common.WS_INLINE
%ignore WS_INLINE
%ignore /#[^\n]*/               // line comments start with #

// Number literals supporting multiple bases
NUMBER: HEX_NUMBER | OCT_NUMBER | BIN_NUMBER | DEC_NUMBER

HEX_NUMBER: /0[xX][0-9a-fA-F]+/
OCT_NUMBER: /0[oO][0-7]+/
BIN_NUMBER: /0[bB][01]+/
DEC_NUMBER: /[+-]?[0-9]+/

// Keywords for special forms (must come before NAME to take precedence)
WHEN_KW: "when"

// Type keywords
INT_KW: "int"
SIGNAL_KW: "Signal"
SIGNALTYPE_KW: "SignalType" 
ENTITY_KW: "Entity"
MEMORY_KW: "Memory"
BUNDLE_KW: "Bundle"

// Bundle comparison keywords
ANY_KW: "any"
ALL_KW: "all"

// For loop keywords
FOR_KW: "for"
IN_KW: "in"
STEP_KW: "step"

// Range operator (must be before other operators)
RANGE_OP: ".."

// Operator Tokens
// Note: Lark automatically handles longest-match, but we define multi-char operators first for clarity
POWER_OP: "**"
SHIFT_OP.2: "<<" | ">>"
LOGIC_AND: "&&" | "and"
LOGIC_OR: "||" | "or"
COMP_OP: "==" | "!=" | "<=" | ">=" | "<" | ">"
BITWISE_AND: "AND"
BITWISE_XOR: "XOR"
BITWISE_OR: "OR"
MUL_OP: "*" | "/" | "%"
ADD_OP: "+" | "-"
OUTPUT_SPEC: ":"
PROJ_OP: "|"
UNARY_OP: "+" | "-" | "!"

NAME: /[A-Za-z_][A-Za-z0-9_]*/

// ---------------------------------
// Entry point
// ---------------------------------
start: statement*

// ---------------------------------
// Statements (terminated by semicolon), and decls
// ---------------------------------
statement: decl_stmt ";"                    -> decl_stmt
         | assign_stmt ";"                  -> assign_stmt
         | expr_stmt ";"                    -> statement_expr_stmt
         | return_stmt ";"                  -> return_stmt
         | import_stmt ";"                  -> import_stmt
         | func_decl                        -> func_decl   // function bodies contain their own semicolons
         | mem_decl ";"                     -> mem_decl
         | for_stmt                         -> for_stmt

decl_stmt: type_name NAME "=" expr

// Memory declaration with optional type annotation
// Memory counter: "signal-A";
mem_decl: MEMORY_KW NAME [":" STRING]

type_name: INT_KW | SIGNAL_KW | SIGNALTYPE_KW | ENTITY_KW | BUNDLE_KW

assign_stmt: lvalue "=" expr

lvalue: NAME ("." NAME)?                    // variable or property assign (e.g. lamp.enable)

expr_stmt: expr

return_stmt: "return" expr

import_stmt: "import" STRING ["as" NAME]



// ---------------------------------
// For loops
// ---------------------------------
for_stmt: FOR_KW NAME IN_KW for_iterator "{" statement* "}"

for_iterator: range_iterator | list_iterator
// Allow expressions (including variable references) for range bounds
// These must be compile-time constant expressions
range_iterator: range_bound RANGE_OP range_bound [STEP_KW range_bound]
list_iterator: "[" [NUMBER ("," NUMBER)*] "]"

// Range bounds can be a number literal or a simple name (variable reference)
range_bound: NUMBER | NAME

// ---------------------------------
// Functions
// ---------------------------------
func_decl: "func" NAME "(" [typed_param_list] ")" "{" statement* "}"

typed_param_list: typed_param ("," typed_param)*

typed_param: param_type NAME

param_type: INT_KW | SIGNAL_KW | ENTITY_KW

// ---------------------------------
// Expressions with precedence
// Precedence from LOWEST (loosest) to HIGHEST (tightest):
//  logic_or -> logic_and -> output_spec -> comparison -> projection -> 
//  bitwise_or -> bitwise_xor -> bitwise_and -> shift -> add -> mul -> power -> unary -> primary
// ---------------------------------
expr: logic_or

logic_or: logic_and ( LOGIC_OR logic_and )*

logic_and: output_spec ( LOGIC_AND output_spec )*

// Output specifier for decider copy-count-from-input
output_spec: comparison [ OUTPUT_SPEC output_value ]

output_value: primary

comparison: projection ( COMP_OP projection )*

projection: bitwise_or ( PROJ_OP type_literal )*

bitwise_or: bitwise_xor ( BITWISE_OR bitwise_xor )*

bitwise_xor: bitwise_and ( BITWISE_XOR bitwise_and )*

bitwise_and: shift ( BITWISE_AND shift )*

shift: add ( SHIFT_OP add )*

add: mul ( ADD_OP mul )*

mul: power ( MUL_OP power )*

// Power is RIGHT-ASSOCIATIVE: 2**3**4 = 2**(3**4)
power: unary ( POWER_OP power )?

unary: UNARY_OP unary
     | primary

// primary expressions (constructors, calls, memory ops, property access, bundle operations)
primary: postfix_expr

// Postfix expressions allow chaining: entity.output["signal-A"]
postfix_expr: atom ( "[" STRING "]" )*       -> bundle_select_chain

atom: literal
    | signal_literal                       // New signal literal syntax
    | bundle_any                           // any(bundle) for anything comparisons
    | bundle_all                           // all(bundle) for everything comparisons
    | memory_read                          // mem.read() method
    | memory_write                         // mem.write(value) method
    | memory_write_when                    // mem.write(value, when=cond) method
    | memory_latch_write                   // mem.write(value, set=s, reset=r) latch method
    | brace_literal                        // Either dict { k: v } or bundle { elem, elem }
    | call_expr                            // General function calls after specific forms
    | method_call
    | lvalue                               // Simple identifiers last
    | "(" expr ")"

// Memory method calls (must come before generic method_call to take precedence)
memory_read: NAME "." "read" "(" ")"
memory_write: NAME "." "write" "(" expr ")"
memory_write_when: NAME "." "write" "(" expr "," WHEN_KW "=" expr ")"

// Latch write: mem.write(value, set=s, reset=r) for SR latch (set priority)
//              mem.write(value, reset=r, set=s) for RS latch (reset priority)
// The ORDER of set/reset determines priority (first one wins in conflict)
SET_KW: "set"
RESET_KW: "reset"
memory_latch_write: NAME "." "write" "(" expr "," latch_kwargs ")"

// Two orderings for set/reset - order determines priority
latch_kwargs: SET_KW "=" expr "," RESET_KW "=" expr    -> latch_set_reset
            | RESET_KW "=" expr "," SET_KW "=" expr    -> latch_reset_set

call_expr: NAME "(" [arglist] ")"
method_call: NAME "." NAME "(" [arglist] ")"

arglist: expr ("," expr)*

// Unified brace literal - disambiguated in transformer based on content
// If elements have ":", it's a dict literal. Otherwise it's a bundle literal.
brace_literal: "{" "}"                                      -> empty_brace
             | "{" dict_item ("," dict_item)* "}"           -> dict_literal
             | "{" bundle_element ("," bundle_element)* "}" -> bundle_literal

dict_item: (STRING | NAME) ":" expr

bundle_element: expr

// Bundle comparison functions
bundle_any: ANY_KW "(" expr ")"
bundle_all: ALL_KW "(" expr ")"

// Signal literal syntax: ("type", value) or just value
signal_literal: "(" type_literal "," expr ")"    -> signal_with_type
              | NUMBER                          -> signal_constant

// Type literal can be a string, a name, or a property access (for signal.type)
type_literal: STRING
            | type_property_access
            | NAME

// Property access for signal.type - extracts signal type at compile time
type_property_access: NAME "." NAME

literal: STRING    -> string

// ---------------------------------
// Tokens & whitespace
// ---------------------------------
%ignore /[ \t\f\r\n]+/
%ignore /\/\/[^\r\n]*/  // Line comments
