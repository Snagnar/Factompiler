# Test 14: Memory and entity integration
# Tests: memory operations with entity properties, entity-driven state machines

# Entities for testing
Entity controller_lamp = place("small-lamp", 0, 0);
Entity status_lamp = place("small-lamp", 5, 0);
Entity indicator_lamp = place("small-lamp", 10, 0);

# Memory for state tracking
Memory entity_state;
Memory blink_counter;
Memory last_lamp_status;

write(0, entity_state, when=once);
write(0, blink_counter, when=once);
write(0, last_lamp_status, when=once);

# Input controls
Signal mode_selector = 100 % 3;  # 0, 1, or 2
Signal enable_signal = 110 > 0;

# Entity property control based on memory state
Signal current_state = read(entity_state);
controller_lamp.enable = (current_state == 1) || (current_state == 2);

# Read entity property and store in memory
Signal lamp_is_on = controller_lamp.enable;
Signal last_status = read(last_lamp_status);
Signal status_changed = lamp_is_on != last_status;

# State machine driven by entity status
Signal next_state = 
    (current_state == 0 && enable_signal) * 1 +
    (current_state == 1 && status_changed) * 2 +
    (current_state == 2 && !enable_signal) * 0 +
    (1 - ((current_state == 0 && enable_signal) + 
          (current_state == 1 && status_changed) + 
          (current_state == 2 && !enable_signal))) * current_state;

write(next_state, entity_state, when=1);
write(lamp_is_on, last_lamp_status, when=1);

# Blinking pattern based on memory
Signal blink_count = read(blink_counter);
write((blink_count + 1) % 20, blink_counter, when=1);
Signal should_blink = current_state == 2;
status_lamp.enable = should_blink && ((blink_count % 10) < 5);

# Indicator lamp shows mode
indicator_lamp.enable = mode_selector > 0;

# Complex entity property calculations
Signal total_lamps_on = controller_lamp.enable + status_lamp.enable + indicator_lamp.enable;
Signal any_lamp_on = total_lamps_on > 0;

# Entity placement based on memory values  
Signal memory_x = read(entity_state) * 3;
Signal memory_y = read(blink_counter) / 10;
Entity dynamic_entity = place("fast-inserter", memory_x, memory_y);

# Property assignment from memory
dynamic_entity.enable = (read(entity_state) == 2) && (read(blink_counter) > 10);
