# Memory Types Showcase
# This program demonstrates all supported memory optimizations

# 1. Standard SR Latch (no arithmetic optimization possible)
# Simple set/reset memory - can't be optimized to arithmetic feedback
Memory sr_latch: "signal-A";
sr_latch.write(("signal-A", 1));  # Always writes 1, needs SR latch

# Lamp 1: Blinks when sr_latch is set
Entity lamp_sr = place("small-lamp", 0, 0);
lamp_sr.enable = sr_latch.read() > 0;


# 2. Single-Operation Arithmetic Feedback
# Simple incrementing counter - optimized to 1 combinator with self-feedback
Memory counter_simple: "signal-B";
counter_simple.write(counter_simple.read() + 1);

# Lamp 2: Blinks every 10 ticks (when counter_simple % 10 == 0)
Signal blink_simple = counter_simple.read() % 10 == 0;
Entity lamp_simple = place("small-lamp", 2, 0);
lamp_simple.enable = blink_simple;


# 3. Multi-Operation Arithmetic Feedback (modulo)
# Counter with wraparound - optimized to 2 combinators with feedback loop
Memory counter_mod10: "signal-C";
counter_mod10.write((counter_mod10.read() + 1) % 10);

# Lamp 3: On when counter is 0 (once every 10 ticks)
Entity lamp_mod = place("small-lamp", 4, 0);
lamp_mod.enable = counter_mod10.read() == 0;


# 4. Long Chain Arithmetic Feedback (10 operations)
# Complex pattern generator with many operations
Memory pattern_gen: "signal-D";
Signal step1 = pattern_gen.read() + 1;
Signal step2 = step1 * 3;
Signal step3 = step2 % 17;
Signal step4 = step3 + 5;
Signal step5 = step4 * 2;
Signal step6 = step5 % 31;
Signal step7 = step6 + 7;
Signal step8 = step7 * 4;
Signal step9 = step8 % 53;
Signal step10 = step9 + 11;
Signal final_pattern = step10 % 100;
pattern_gen.write(final_pattern);

# Lamp 4: Complex blinking pattern (on when pattern divisible by 7)
Entity lamp_pattern = place("small-lamp", 6, 0);
lamp_pattern.enable = pattern_gen.read() % 7 == 0;


# 5. Multiple Operations with Different Outputs
# Counter used in multiple ways
Memory counter_multi: "signal-E";
counter_multi.write((counter_multi.read() + 1) % 20);

# Multiple lamps showing different aspects of the same counter
Signal is_even = counter_multi.read() % 2 == 0;
Signal is_div5 = counter_multi.read() % 5 == 0;
Signal is_high = counter_multi.read() > 10;

Entity lamp_even = place("small-lamp", 8, 0);
lamp_even.enable = is_even;

Entity lamp_div5 = place("small-lamp", 10, 0);
lamp_div5.enable = is_div5;

Entity lamp_high = place("small-lamp", 12, 0);
lamp_high.enable = is_high;


# 6. Conditional Write
# Counter that only increments when below threshold
Memory conditional_counter: "signal-F";
Signal can_increment = conditional_counter.read() < 15;
conditional_counter.write(conditional_counter.read() + 1, when=can_increment);

# Lamp 6: On when counter reaches max
Entity lamp_maxed = place("small-lamp", 14, 0);
lamp_maxed.enable = conditional_counter.read() >= 15;