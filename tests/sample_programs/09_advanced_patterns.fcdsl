# Test 9: Advanced patterns - counters, filters, accumulators
# Tests: complex memory patterns, filtering, accumulation

# Multi-counter system
Memory up_counter;
Memory down_counter;
Memory event_count;

write(0, up_counter, when=once);
write(100, down_counter, when=once);
write(0, event_count, when=once);

Signal increment = ("signal-I", 0) > 0;
Signal decrement = ("signal-D", 1) > 0;
Signal reset = ("signal-R", 2) > 0;

# Counter logic with bounds checking
Signal up_val = read(up_counter);
Signal down_val = read(down_counter);

Signal new_up = 
    reset * 0 + 
    (1 - reset) * (up_val + increment * (up_val < 999));

Signal new_down = 
    reset * 100 + 
    (1 - reset) * (down_val - decrement * (down_val > 0));

write(new_up, up_counter, when=1);
write(new_down, down_counter, when=1);

# Event detection and counting
Signal up_overflow = (up_val >= 999) && increment;
Signal down_underflow = (down_val <= 0) && decrement;
Signal any_event = up_overflow || down_underflow;

Signal events = read(event_count);
write(events + any_event, event_count, when=1);

# Filtered accumulator - only accumulate positive values
Memory filtered_sum;

write(0, filtered_sum, when=once);
Signal input_val = 130;
Signal should_accumulate = input_val > 0;
Signal current_sum = read(filtered_sum);
write(current_sum + (input_val * should_accumulate), filtered_sum, when=1);

# Output status projections without bundles
Signal status_up = up_val | "signal-red";
Signal status_down = down_val | "signal-green";
Signal status_events = events | "signal-blue";
Signal status_sum = current_sum | "signal-yellow";
