# Advanced Entity Properties - Simplified for DSL Compatibility
# Tests complex entity property control using circuit network features

# =============================================================================
# INPUT SIGNALS  
# =============================================================================

Signal item_count = ("iron-plate", 0);
Signal copper_count = ("copper-plate", 1);
Signal production_rate = ("signal-P", 2);
Signal error_state = ("signal-E", 3);
Signal system_health = ("signal-H", 4);

# =============================================================================
# SMART INSERTER CONTROL
# =============================================================================

# Filter inserter with dynamic control
Entity smart_inserter = place("inserter", 0, 0);

# Using logical operators instead of ternary
Signal high_volume = item_count > 50;
smart_inserter.enable = item_count > 0;

# Stack inserter with circuit control  
Entity stack_inserter = place("stack-inserter", 2, 0);
stack_inserter.enable = item_count < 1000;

# =============================================================================
# BELT AND TRANSPORT SYSTEMS
# =============================================================================

Entity transport_belt = place("transport-belt", 5, 0);
Entity fast_belt = place("fast-transport-belt", 7, 0);

# Belt control based on production rate
Signal high_production = production_rate > 100;

# Splitter with priority control
Entity smart_splitter = place("splitter", 10, 0);
Signal belt_iron = ("iron-plate", 10);
Signal belt_copper = ("copper-plate", 11);

# =============================================================================
# TRAIN SYSTEM INTEGRATION
# =============================================================================

Entity cargo_station = place("train-stop", 14, 0);
cargo_station.enable = item_count > 0;

# Train stop with limit based on inventory
Signal need_multiple_trains = item_count > 500;

# =============================================================================
# PRODUCTION CONTROL
# =============================================================================

Entity assembler1 = place("assembling-machine-1", 20, 0);
Entity assembler2 = place("assembling-machine-2", 24, 0);

# Recipe selection based on resource availability
Signal prefer_iron = item_count > copper_count;
assembler1.enable = item_count > 10;
assembler2.enable = copper_count > 10;

# =============================================================================
# ROBOPORT AND LOGISTICS
# =============================================================================

Entity roboport = place("roboport", 29, 0);
roboport.enable = item_count > 100;

# Chest with circuit control
Entity provider = place("iron-chest", 34, 0);
Entity requester = place("steel-chest", 36, 0);

Signal chest_total = item_count + copper_count;
Signal chest_needs_items = chest_total < 1000;

# =============================================================================
# POWER AND INFRASTRUCTURE
# =============================================================================

Entity electric_pole = place("medium-electric-pole", 35, 0);
Entity lamp = place("small-lamp", 37, 0);

# Lamp control based on system status
Signal system_ok = system_health > 0;
lamp.enable = system_ok;

# =============================================================================
# MEMORY AND STATE MANAGEMENT
# =============================================================================

# Memory for tracking production state
Memory production_state: "signal-0";
Memory item_history: "signal-0";


# Update production state based on conditions
Signal state_change = item_count > read(item_history);
write(state_change && 1 || 0, production_state, when=1);
write(item_count | "signal-0", item_history, when=1);

# =============================================================================
# COMPLEX CONDITIONAL LOGIC
# =============================================================================

# Multi-condition logic for system control
Signal low_items = item_count < 10;
Signal low_copper = copper_count < 10;
Signal resource_shortage = low_items || low_copper;

Signal factory_running = production_rate > 0;
Signal factory_idle = production_rate == 0;

# System state calculation
Signal critical_state = error_state || resource_shortage;
Signal normal_operation = factory_running && !critical_state;

# =============================================================================
# AGGREGATED SIGNAL OPERATIONS WITH PROPERTIES
# =============================================================================

Signal production_iron = item_count | "iron-plate";
Signal production_copper = copper_count | "signal-C";
Signal production_rate_signal = production_rate | "signal-P";
Signal production_status = production_iron + production_copper + production_rate_signal;

Signal system_ok_status = normal_operation | "signal-O";
Signal system_error = critical_state | "signal-E";
Signal system_low = resource_shortage | "signal-L";
Signal system_status = system_ok_status + system_error + system_low;

# =============================================================================
# OUTPUT CONTROL SIGNALS
# =============================================================================

Signal master_enable = !critical_state;
Signal production_efficiency = (item_count * 100) / (item_count + 1);  # Avoid division by zero

# Final control signals
Signal factory_control = master_enable && factory_running;
Signal maintenance_needed = critical_state || (system_health < 50);