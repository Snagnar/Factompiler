# Advanced Memory Module Test
# Demonstrates full memory capabilities including:
# - Storing arbitrary signal types (items, fluids, virtuals)
# - Conditional writes based on signal values
# - Reading and manipulating stored values
# - Memory state machines

# =============================================================================
# BASIC MEMORY STORAGE - Different Signal Types
# =============================================================================

# Store an item signal
Memory iron_storage: "iron-plate";
Memory copper_storage: "copper-plate";

# Store a fluid signal
Memory water_level: "water";

# Store a virtual signal for state
Memory system_state: "signal-S";

# Store a counter
Memory tick_counter: "signal-0";

# =============================================================================
# CONDITIONAL WRITES - Write only when conditions are met
# =============================================================================

# Scenario 1: Write only if current value is zero (initialization check)
# CORRECT PATTERN: Read current value, write new value if condition met, otherwise write current value back
Signal current_iron = iron_storage.read();
Signal iron_input = 50 | "iron-plate";
Signal should_write_iron = (current_iron == 0);  # 1 if true, 0 if false
iron_storage.write(iron_input, when=should_write_iron);  # Writes 50 if storage is 0, otherwise holds

# Scenario 2: Write only if input exceeds threshold
Signal copper_input = 75 | "copper-plate";
Signal should_store_copper = copper_input > 100;  # Boolean: 1 if true, 0 if false
Signal copper_current = copper_storage.read();
copper_storage.write(copper_input, when=should_store_copper);  # Writes input if > 100, otherwise holds

# Scenario 3: Conditional increment - add to counter only if condition met
Signal current_count = tick_counter.read();
Signal enable_counting = 1;  # This could be from any condition
Signal new_count = current_count + (enable_counting | "signal-0");
tick_counter.write(new_count, when=enable_counting);  # Only writes when counting is enabled

# =============================================================================
# COMPLEX CONDITIONAL WRITES - Multiple Conditions
# =============================================================================

# Write to water storage only if:
# 1. Current level is low (< 500), AND
# 2. Pump is active (simulated), AND
# 3. Input is available
Signal current_water = water_level.read();
Signal water_is_low = current_water < 500;
Signal pump_active = 1;  # Simulated
Signal water_input = 200 | "water";
Signal should_refill = water_is_low && pump_active;
Signal water_refill_value = current_water + water_input;
water_level.write(water_refill_value, when=should_refill);

# =============================================================================
# MEMORY-BASED STATE MACHINE
# =============================================================================

# State machine: 0 = idle, 1 = processing, 2 = complete, 3 = error
Signal current_state = system_state.read();

# Transitions based on conditions
Signal has_input = iron_input > 0;
Signal processing_done = current_count > 10;
Signal has_error = 0;  # Simulated error condition

# State transition logic
Signal idle_to_processing = (current_state == 0) && has_input;
Signal processing_to_complete = (current_state == 1) && processing_done;
Signal any_to_error = has_error;
Signal complete_to_idle = (current_state == 2);

Signal next_state = 
    ((idle_to_processing * 1) +           # Go to state 1
    (processing_to_complete * 2) +        # Go to state 2
    (complete_to_idle * 0) +              # Go to state 0
    (any_to_error * 3) +                  # Go to state 3
    (!(idle_to_processing || processing_to_complete || complete_to_idle || any_to_error)) * current_state) | "signal-S";  # Stay in current state

system_state.write(next_state);

# =============================================================================
# STORING MULTIPLE VALUES - Using Different Memory Cells
# =============================================================================

Memory max_iron_seen: "iron-plate";
Memory min_copper_seen: "copper-plate";

Signal current_max = max_iron_seen.read();
Signal should_update_max = iron_input > current_max;
max_iron_seen.write(iron_input, when=should_update_max);

Signal current_min = min_copper_seen.read();
Signal should_update_min = copper_input < current_min;
min_copper_seen.write(copper_input, when=should_update_min);

# =============================================================================
# CLEARING/RESETTING MEMORY
# =============================================================================

Signal reset_signal = 0;  # Set to 1 to trigger reset

# Write cleared values back when reset is triggered
iron_storage.write(0 | "iron-plate", when=reset_signal);
copper_storage.write(0 | "copper-plate", when=reset_signal);

# =============================================================================
# READING AND COMBINING MEMORY VALUES
# =============================================================================

# Read all storage values
Signal total_iron = iron_storage.read();
Signal total_copper = copper_storage.read();
Signal total_water = water_level.read();

# Combine for summary signal
Signal total_resources = (total_iron | "signal-R") + (total_copper | "signal-R") + (total_water / 10 | "signal-R");

# =============================================================================
# CONDITIONAL SWAP - Exchange values between memories
# =============================================================================

Signal should_swap = 0;  # Condition to swap iron and copper storage
Signal iron_after_swap = (should_swap * (copper_storage.read() | "iron-plate") + (!should_swap) * iron_storage.read());
Signal copper_after_swap = (should_swap * (iron_storage.read() | "copper-plate") + (!should_swap) * copper_storage.read());

iron_storage.write(iron_after_swap, when=should_swap);
copper_storage.write(copper_after_swap, when=should_swap);

# =============================================================================
# OUTPUT SIGNALS - Based on Memory State
# =============================================================================

Signal storage_full = (total_iron > 1000) || (total_copper > 1000);
Signal storage_empty = (total_iron == 0) && (total_copper == 0);
Signal system_ready = (current_state == 0) && !storage_empty;
Signal system_processing = (current_state == 1);
Signal system_done = (current_state == 2);
