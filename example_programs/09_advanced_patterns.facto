# Test 9: Advanced patterns - counters, filters, accumulators
# Tests: complex memory patterns, filtering, accumulation

# Multi-counter system
Memory up_counter: "signal-0";
Memory down_counter: "signal-0";
Memory event_count: "signal-0";


Signal increment = ("signal-I", 0) | "signal-0";
Signal decrement = ("signal-D", 1) | "signal-0";
Signal reset_signal = ("signal-R", 2) | "signal-0";

# Counter logic with bounds checking using condition : value syntax
Signal up_val = up_counter.read();
Signal down_val = down_counter.read();

# Use condition : value for cleaner conditional logic
Signal new_up = 
    ((reset_signal > 0) : 0) + 
    ((reset_signal == 0) : (up_val + ((up_val < 999) : increment)));

Signal new_down = 
    ((reset_signal > 0) : 100) + 
    ((reset_signal == 0) : (down_val - ((down_val > 0) : decrement)));

up_counter.write(new_up);
down_counter.write(new_down);

# Event detection and counting
Signal up_overflow = (up_val >= 999) && increment;
Signal down_underflow = (down_val <= 0) && decrement;
Signal any_event = up_overflow || down_underflow;

Signal events = event_count.read();
event_count.write(events + any_event);

# Filtered accumulator - only accumulate positive values
Memory filtered_sum: "signal-0";

Signal input_val = 130;
Signal should_accumulate = input_val > 0;
Signal current_sum = filtered_sum.read();
# Use condition : value for conditional accumulation
filtered_sum.write(current_sum + ((should_accumulate) : input_val));

# Output status projections without bundles
Signal status_up = up_val | "signal-red";
Signal status_down = down_val | "signal-green";
Signal status_events = events | "signal-blue";
Signal status_sum = current_sum | "signal-yellow";
