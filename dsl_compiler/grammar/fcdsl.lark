// fcdsl.lark
// Factorio Circuit DSL grammar (Lark format)
// - Use with Lark (LALR). Keeps operator precedence explicit.
// - '|' projection binds looser than + and * but tighter than comparisons.

%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_NUMBER    -> NUMBER
%import common.WS_INLINE
%ignore WS_INLINE
%ignore /#[^\n]*/               // line comments start with #

// Keywords for special forms (must come before NAME to take precedence)
READ_KW: "read"
WRITE_KW: "write"
WHEN_KW: "when"
MEM_KW: "mem"
ONCE_KW: "once"

// Type keywords
INT_KW: "int"
SIGNAL_KW: "Signal"
SIGNALTYPE_KW: "SignalType" 
ENTITY_KW: "Entity"
MEMORY_KW: "Memory"

NAME: /[A-Za-z_][A-Za-z0-9_-]*/   // allow hyphens in names for type-like identifiers

// ---------------------------------
// Entry point
// ---------------------------------
start: statement*

// ---------------------------------
// Statements (terminated by semicolon), and decls
// ---------------------------------
statement: decl_stmt ";"                    -> decl_stmt
         | assign_stmt ";"                  -> assign_stmt
         | expr_stmt ";"                    -> statement_expr_stmt
         | return_stmt ";"                  -> return_stmt
         | import_stmt ";"                  -> import_stmt
         | func_decl                        -> func_decl   // function bodies contain their own semicolons
         | mem_decl ";"                     -> mem_decl

decl_stmt: type_name NAME "=" expr

mem_decl: (MEMORY_KW | MEM_KW) NAME

type_name: INT_KW | SIGNAL_KW | SIGNALTYPE_KW | ENTITY_KW

assign_stmt: lvalue "=" expr

lvalue: NAME ("." NAME)?                    // variable or property assign (e.g. lamp.enable)

expr_stmt: expr

return_stmt: "return" expr

import_stmt: "import" STRING ["as" NAME]

// ---------------------------------
// Functions
// ---------------------------------
func_decl: "func" NAME "(" [param_list] ")" "{" statement* "}"

param_list: NAME ("," NAME)*

// ---------------------------------
// Expressions with precedence
// Precedence (tightest -> loosest):
//  primary -> unary -> mul -> add -> projection (|) -> comparison -> logic
// ---------------------------------
expr: logic

logic: comparison ( LOGIC_OP comparison )*

comparison: projection ( COMP_OP projection )*

LOGIC_OP: "&&" | "||"
COMP_OP: "==" | "!=" | "<=" | ">=" | "<" | ">"

projection: add ( PROJ_OP type_literal )*        // projection binds looser than +; allow multiple chained projections (rare)

PROJ_OP: "|"

add: mul ( ADD_OP mul )*

mul: unary ( MUL_OP unary )*

ADD_OP: "+" | "-"
MUL_OP: "*" | "/" | "%"

unary: UNARY_OP unary
     | primary

UNARY_OP: "+" | "-" | "!"

// primary expressions (constructors, calls, memory ops, property access)
primary: literal
     | signal_literal                       // New signal literal syntax
     | READ_KW "(" NAME ")"
     | WRITE_KW "(" expr "," NAME ["," WHEN_KW "=" write_when] ")"
     | dict_literal
       | call_expr                            // General function calls after specific forms
       | method_call
       | lvalue                               // Simple identifiers last
       | "(" expr ")"

write_when: expr
          | ONCE_KW

call_expr: NAME "(" [arglist] ")"
method_call: NAME "." NAME "(" [arglist] ")"

arglist: expr ("," expr)*

dict_literal: "{" [dict_item ("," dict_item)*] "}"
dict_item: (STRING | NAME) ":" expr

// Signal literal syntax: ("type", value) or just value
signal_literal: "(" type_literal "," expr ")"    -> signal_with_type
              | NUMBER                          -> signal_constant

type_literal: STRING
            | NAME

literal: STRING    -> string

// ---------------------------------
// Tokens & whitespace
// ---------------------------------
%ignore /[ \t\f\r\n]+/
%ignore /\/\/[^\r\n]*/  // Line comments
