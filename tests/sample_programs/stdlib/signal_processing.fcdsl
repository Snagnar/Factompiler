# Signal processing library  
# Provides filtering and signal manipulation functions

func smooth_filter(signal, window_size) {
    # Simple moving average filter
    Memory accumulator = 0;
    Memory sample_count = 0;
    
    Signal current_sum = read(accumulator);
    Signal count = read(sample_count);
    
    Signal new_sum = current_sum + signal;
    Signal new_count = count + 1;
    
    # Reset when window is full
    Signal should_reset = new_count >= window_size;
    Signal final_sum = should_reset * signal + (1 - should_reset) * new_sum;
    Signal final_count = should_reset * 1 + (1 - should_reset) * new_count;
    
    write(final_sum, accumulator, when=1);
    write(final_count, sample_count, when=1);
    
    return final_sum / final_count;
}

func high_pass_filter(signal, cutoff) {
    # Simple high-pass filter
    Memory last_input = 0;
    Memory last_output = 0;
    
    Signal last_in = read(last_input);
    Signal last_out = read(last_output);
    
    # High-pass: output = signal - last_input + 0.9 * last_output
    Signal output = signal - last_in + (last_out * 9) / 10;
    
    write(signal, last_input, when=1);
    write(output, last_output, when=1);
    
    return (output > cutoff) * output;
}

func low_pass_filter(signal, cutoff) {
    # Simple low-pass filter  
Memory filtered_value = 0;
    
    Signal current = read(filtered_value);
    # Low-pass: output = 0.1 * signal + 0.9 * last_output
    Signal output = (signal + current * 9) / 10;
    
    write(output, filtered_value, when=1);
    
    return (output < cutoff) * output + (output >= cutoff) * cutoff;
}

func combine_signals(signal_a, signal_b, signal_c) {
    # Combine three signals with weighting
    Signal weighted_sum = signal_a * 5 + signal_b * 3 + signal_c * 2;
    Signal average = weighted_sum / 10;
    return average;
}
