# Memory utilities library
# Provides common memory-based operations and patterns

func delay_signal(signal, delay_ticks) {
    # Simple delay using memory - stores signal for delay_ticks
Memory delayed_value = 0;
Memory tick_counter = 0;
    
    Signal ticks = read(tick_counter);
    Signal should_update = (ticks % delay_ticks) == 0;
    
    Signal current_delayed = read(delayed_value);
    Signal new_delayed = should_update * signal + (1 - should_update) * current_delayed;
    
    write(delayed_value, new_delayed);
    write(tick_counter, ticks + 1);
    
    return current_delayed;
}

func accumulate_clamped(signal, min_val, max_val) {
    # Accumulate signal with min/max bounds
Memory accumulator = 0;
    
    Signal current = read(accumulator);
    Signal new_val = current + signal;
    
    # Clamp between min and max
    Signal clamped = (new_val < min_val) * min_val + 
                  (new_val > max_val) * max_val +
                  ((new_val >= min_val) && (new_val <= max_val)) * new_val;
    
    write(accumulator, clamped);
    return clamped;
}

func rate_limiter(signal, max_change_per_tick) {
    # Limit rate of change in signal
Memory last_value = 0;
    
    Signal last = read(last_value);
    Signal change = signal - last;
    Signal abs_change = (change >= 0) * change + (change < 0) * (-change);
    
    Signal limited_change = (abs_change > max_change_per_tick) * 
                        ((change >= 0) * max_change_per_tick + (change < 0) * (-max_change_per_tick)) +
                        (abs_change <= max_change_per_tick) * change;
    
    Signal new_value = last + limited_change;
    write(last_value, new_value);
    
    return new_value;
}
