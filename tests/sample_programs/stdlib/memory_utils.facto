# Memory utilities library
# Provides common memory-based operations and patterns

func delay_signal(Signal signal, int delay_ticks) {
    # Simple delay using memory - stores signal for delay_ticks
    Memory delayed_value: "signal-0";
    Memory tick_counter: "signal-0";

            
    Signal ticks = tick_counter.read();
    Signal should_update = (ticks % delay_ticks) == 0;
    
    Signal current_delayed = delayed_value.read();
    Signal new_delayed = should_update * signal + (1 - should_update) * current_delayed;
    
    delayed_value.write(new_delayed);
    tick_counter.write(ticks + 1);
    
    return current_delayed;
}

func accumulate_clamped(Signal signal, int min_val, int max_val) {
    # Accumulate signal with min/max bounds
    Memory accumulator: "signal-0";

        
    Signal current = accumulator.read();
    Signal new_val = current + signal;
    
    # Clamp between min and max
    Signal clamped = (new_val < min_val) * min_val + 
                  (new_val > max_val) * max_val +
                  ((new_val >= min_val) && (new_val <= max_val)) * new_val;
    
    accumulator.write(clamped);
    return clamped;
}

func rate_limiter(Signal signal, int max_change_per_tick) {
    # Limit rate of change in signal
    Memory last_value: "signal-0";

        
    Signal last = last_value.read();
    Signal change = signal - last;
    Signal abs_change = (change >= 0) * change + (change < 0) * (-change);
    
    Signal limited_change = (abs_change > max_change_per_tick) * 
                        ((change >= 0) * max_change_per_tick + (change < 0) * (-max_change_per_tick)) +
                        (abs_change <= max_change_per_tick) * change;
    
    Signal new_value = last + limited_change;
    last_value.write(new_value);
    
    return new_value;
}
