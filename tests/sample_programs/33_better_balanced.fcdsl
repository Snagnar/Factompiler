# Balanced Train Loader (MadZuri Design)
# ======================================
#
# This implements the classic MadZuri balanced loader pattern:
# 1. Sum all chest contents via wire merge
# 2. Arithmetic combinator: Each / -N → negative average
# 3. Each inserter sees: own_chest + negative_average
# 4. Enable when sum < 1 (chest at or below average)
#
# DSL features used:
# - entity.output to read chest contents as Bundle
# - Bundle arithmetic (Each / -N) for negative average
# - any(bundle) for multi-item compatible enable condition
# - Automatic wire color inference for merge conflicts

int NUM_CHESTS = 6;

# ============================================================================
# PLACE BELTS AND BELT-TO-CHEST INSERTERS
# Direction 8 = SOUTH: picks from north (y=0 belt), drops to south (y=2 chest)
# ============================================================================
for i in 0..NUM_CHESTS {
    place("express-transport-belt", i, 0, {direction: 4});
    place("fast-inserter", i, 1, {direction: 0});
}

# ============================================================================
# PLACE RAILS (for train wagon)
# Direction 4 = EAST for horizontal rails
# ============================================================================
for i in 0..NUM_CHESTS step 2 {
    place("straight-rail", i, 4, {direction: 4});
}

# ============================================================================
# PLACE CHESTS - Fixed positions at y=2
# ============================================================================
Entity c1 = place("steel-chest", 0, 2);
Entity c2 = place("steel-chest", 1, 2);
Entity c3 = place("steel-chest", 2, 2);
Entity c4 = place("steel-chest", 3, 2);
Entity c5 = place("steel-chest", 4, 2);
Entity c6 = place("steel-chest", 5, 2);

# ============================================================================
# BUNDLE OPERATIONS: Sum and Negative Average
# ============================================================================

# Read chest contents as Bundles using entity.output
Bundle contents1 = c1.output;
Bundle contents2 = c2.output;
Bundle contents3 = c3.output;
Bundle contents4 = c4.output;
Bundle contents5 = c5.output;
Bundle contents6 = c6.output;

# Sum all chest contents by combining into one bundle (wire merge)
# This creates a wire network connecting all chests to the combinator input
Bundle total = {contents1, contents2, contents3, contents4, contents5, contents6};

# Calculate negative average using Bundle arithmetic
# Compiles to: Each / -6 = Each
# Output: negative average of all items across all chests
Bundle neg_avg = total / -NUM_CHESTS;

# ============================================================================
# CHEST-TO-TRAIN INSERTERS WITH BALANCED ENABLE CONDITIONS
# Direction 8 = SOUTH: picks from north (y=2 chest), drops to south (y=4 train)
# ============================================================================
Entity ins1 = place("fast-inserter", 0, 3, {direction: 0});
Entity ins2 = place("fast-inserter", 1, 3, {direction: 0});
Entity ins3 = place("fast-inserter", 2, 3, {direction: 0});
Entity ins4 = place("fast-inserter", 3, 3, {direction: 0});
Entity ins5 = place("fast-inserter", 4, 3, {direction: 0});
Entity ins6 = place("fast-inserter", 5, 3, {direction: 0});

# Create per-inserter input bundles:
# Each inserter sees: its own chest contents + the negative average
# Signals sum on the wire: if chest has 100 and avg is 100, result is 0
# 
# Wire color handling:
# - contents1 participates in both 'total' merge and 'input1' merge
# - Compiler automatically assigns different wire colors to prevent double-counting
# - RED wire: combinator output (neg_avg) → inserters
# - GREEN wire: each chest → its own inserter
Bundle input1 = {contents1, neg_avg};
Bundle input2 = {contents2, neg_avg};
Bundle input3 = {contents3, neg_avg};
Bundle input4 = {contents4, neg_avg};
Bundle input5 = {contents5, neg_avg};
Bundle input6 = {contents6, neg_avg};

# Enable condition: any(diff) < 1 means chest is at or below average
# 
# Using any() (signal-anything) instead of all() (signal-everything):
# - any() < 1: TRUE if ANY signal is less than 1 (more permissive, better for multi-item)
# - all() < 1: TRUE only if ALL signals are less than 1
#
# For loading: we want to fill chests that are below average
# - If chest has 80 items and average is 100: diff = 80 + (-100) = -20 → enabled ✓
# - If chest has 100 items and average is 100: diff = 100 + (-100) = 0 → enabled ✓
# - If chest has 120 items and average is 100: diff = 120 + (-100) = 20 → disabled ✓
#
# Using < 1 instead of < 0 allows chests at exactly average to receive items,
# preventing deadlock when all chests have equal contents.
ins1.enable = any(input1) < 1;
ins2.enable = any(input2) < 1;
ins3.enable = any(input3) < 1;
ins4.enable = any(input4) < 1;
ins5.enable = any(input5) < 1;
ins6.enable = any(input6) < 1;
