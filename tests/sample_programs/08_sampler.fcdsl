# Test 8: The 100-tick sampler (from spec example)
# Tests: modulo operations, periodic sampling, complex logic chains

Memory tick = 0;

Signal ONE = 1;

# Increment tick every game tick (unconditional write)
write(read(tick) + ONE, tick, when=1);

Signal tick_mod = read(tick) % 100;
Signal sample_now = (tick_mod == 0);

Signal v = 100;           # implicit signal type __v1
Signal rem = v % 2;
Signal is_even = (rem == 0);

Signal do_output = sample_now * is_even;    # 0/1 gate

Signal scaled = v * 10;
Signal out_value = scaled * do_output;

# Additional complexity: multiple sampling rates
Signal fast_sample = (read(tick) % 10 == 0);
Signal slow_sample = (read(tick) % 1000 == 0);

Signal fast_output = v * fast_sample;
Signal slow_output = (v / 5) * slow_sample;

# Project outputs onto distinct channels without bundles
Signal out_red = out_value | "signal-red";
Signal out_fast_belt = fast_output | "fast-transport-belt";
Signal out_blue = slow_output | "signal-blue";

# Aggregate onto a single channel for export if needed
Signal combined_output = (out_red + out_fast_belt + out_blue) | "signal-each";
